package recollectionControl;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

import dataframe.DataFrame;
import machinations.Model;
import scorer.CrossValidation;
import scorer.Evaluate;

public class ReleaseRecollection2 {
	    

	    /** List of dataframes to evaluate. */
		private List<ArrayList<DataFrame>> memories;
		
		/** The model in which we will take the world with. */
		private Model model;
		
		/** The evaluation of that model. */
		private Evaluate evaluate;
		
		/** Indicates whether there is producer threads still producing cross validations. */
		private boolean producing;
		
		/** Array of producer threads. */
		Thread[] producers;
		
		/** Consumer thread for taking in data. */
		Thread consumer;
		
		/**
		 * RELEASE THE RECOLLECTION!
		 * @param memories list of dataframes to release the recollection on. Generated by recollection itself. 
		 * @param model the model to evaluate. 
		 * @param ev the evaluation function.
		 * @param numProducers the number of producer threads to run cross validations with.
		 */
		public ReleaseRecollection2(List<ArrayList<DataFrame>> memories, Model model, Evaluate ev, int numProducers) {
			this.memories = memories;
			this.model = model;
			this.evaluate = ev;
			producing = true;
			producers = new Thread[numProducers];
		}
		public void run() {
			  // Common buffer created using LinkedBlockingQueue
			BlockingQueue<CrossValidation> EVALUATION_QUEUE = new LinkedBlockingQueue<CrossValidation>();
			//multiple producers
	        for (int i = 0; i < producers.length; i++) {
	            producers[i] = new Thread(new RecollectionProducer2(EVALUATION_QUEUE, producing, memories.get(i), model));
	            producers[i].setName("RecollectionGenerator-"+i);
	            producers[i].start();
	        }
	        consumer = new Thread(new RecollectionConsumer2(EVALUATION_QUEUE,producing,evaluate));
	        consumer.setName("RecollectionEvaluation");
	        consumer.start();
	        for (int i = 0; i < producers.length; i++) {
	            try {
	                producers[i].join();
	                System.out.println("CONFIRMED PRODUCTION");
	            } catch (InterruptedException e) {
	                System.out.println("Error joining producer thread: ");
	                e.printStackTrace();
	            }
	        }
	        try {
	            consumer.join();
	            System.out.println(consumer.isAlive());
	        } catch (InterruptedException e) {
	            System.out.println("Error joining consumer thread: ");
	            e.printStackTrace();
	        }
		}
}
